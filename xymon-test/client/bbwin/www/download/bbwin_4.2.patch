diff -Naur hobbitd/client/bbwin.c hobbitd/client/bbwin.c
--- hobbitd/client/bbwin.c	1970-01-01 01:00:00.000000000 +0100
+++ hobbitd/client/bbwin.c	2008-01-31 15:28:10.000000000 +0100
@@ -0,0 +1,474 @@
+/*----------------------------------------------------------------------------*/
+/* Hobbit message daemon.                                                     */
+/*                                                                            */
+/* Client backend module for BBWin/Windoes client                             */
+/*                                                                            */
+/* Copyright (C) 2006-2008 Henrik Storner <henrik@hswn.dk>                    */
+/* Copyright (C) 2007-2008 Francois Lacroix				      */
+/* Copyright (C) 2007-2008 Etienne Grignon <etienne.grignon@gmail.com>        */
+/*                                                                            */
+/* This program is released under the GNU General Public License (GPL),       */
+/* version 2. See the file "COPYING" for details.                             */
+/*                                                                            */
+/*----------------------------------------------------------------------------*/
+
+static char bbwin_rcsid[] = "$Id: bbwin.c,v 1.5 2008/01/14 21:20:28 henrik Exp $";
+
+static void bbwin_uptime_report(char *hostname, char *clientclass, enum ostype_t os,
+                     void *hinfo, char *fromline, char *timestr,
+                     char *uptimestr)
+{
+        char *p, *myuptimestr = NULL;
+	float loadyellow, loadred;
+        int recentlimit, ancientlimit, maxclockdiff;
+        long uptimesecs = -1;
+        int uptimecolor = COL_GREEN;
+        char msgline[4096];
+        strbuffer_t *upmsg;
+
+	if (!want_msgtype(hinfo, MSG_CPU)) return;
+        if (!uptimestr) return;
+
+	dbgprintf("Uptime check host %s\n", hostname);
+
+        uptimesecs = 0;
+
+	/* Parse to check data */
+        p = strstr(uptimestr, "sec:");
+        if (p) {
+		p += strcspn(p, "0123456789\r\n");
+                uptimesecs = atol(p);
+                dbgprintf("uptimestr [%d]\n", uptimesecs); /* DEBUG TODO REMOVE */
+	}
+	/* Parse to show a nice msg */
+        myuptimestr = strchr(uptimestr, '\n');
+        if (myuptimestr) {
+		++myuptimestr;
+        }
+	get_cpu_thresholds(hinfo, clientclass, &loadyellow, &loadred, &recentlimit, &ancientlimit, &maxclockdiff);
+	dbgprintf("DEBUG recentlimit: [%d] ancienlimit: [%d]\n", recentlimit, ancientlimit); /* DEBUG TODO REMOVE */
+
+        upmsg = newstrbuffer(0);
+        if ((uptimesecs != -1) && (recentlimit != -1) && (uptimesecs < recentlimit)) {
+                if (uptimecolor == COL_GREEN) uptimecolor = COL_YELLOW;
+                addtobuffer(upmsg, "&yellow Machine recently rebooted\n");
+        }
+        if ((uptimesecs != -1) && (ancientlimit != -1) && (uptimesecs > ancientlimit)) {
+                if (uptimecolor == COL_GREEN) uptimecolor = COL_YELLOW;
+                sprintf(msgline, "&yellow Machine has been up more than %d days\n", (ancientlimit / 86400));
+                addtobuffer(upmsg, msgline);
+        }
+
+        init_status(uptimecolor);
+        sprintf(msgline, "status %s.uptime %s %s %s\n",
+                commafy(hostname), colorname(uptimecolor),
+                (timestr ? timestr : "<No timestamp data>"),
+                ((uptimecolor == COL_GREEN) ? "OK" : "NOT ok"));
+
+        addtostatus(msgline);
+	/* And add the info if pb */
+        if (STRBUFLEN(upmsg)) {
+                addtostrstatus(upmsg);
+                addtostatus("\n");
+        }
+        /* And add the msg we recevied */
+        if (myuptimestr) {
+                addtostatus(myuptimestr);
+                addtostatus("\n");
+        }
+
+	dbgprintf("msgline %s", msgline); /* DEBUG TODO REMOVE */ 
+
+        if (fromline && !localmode) addtostatus(fromline);
+        finish_status();
+
+        freestrbuffer(upmsg);
+}
+
+
+static void bbwin_cpu_report(char *hostname, char *clientclass, enum ostype_t os,
+                     void *hinfo, char *fromline, char *timestr,
+                     char *cpuutilstr)
+{
+        char *p, *topstr;
+        float load1, loadyellow, loadred;
+        int recentlimit, ancientlimit, maxclockdiff;
+        int cpucolor = COL_GREEN;
+
+        char msgline[4096];
+        strbuffer_t *cpumsg;
+
+        if (!want_msgtype(hinfo, MSG_CPU)) return;
+        if (!cpuutilstr) return;
+
+	dbgprintf("CPU check host %s\n", hostname);	
+
+	load1 = 0;
+
+        p = strstr(cpuutilstr, "load=");
+        if (p) {
+                p += strcspn(p, "0123456789%\r\n");
+                load1 = atol(p);
+                dbgprintf("load1 [%d]\n", load1); /* DEBUG TODO REMOVE */ 
+        }
+	topstr = strstr(cpuutilstr, "CPU states");
+	if (topstr) {
+		*(topstr - 1) = '\0';
+	}
+	
+	get_cpu_thresholds(hinfo, clientclass, &loadyellow, &loadred, &recentlimit, &ancientlimit, &maxclockdiff);
+	dbgprintf("loadyellow: %d, loadred: %d\n", loadyellow, loadred);
+
+        cpumsg = newstrbuffer(0);
+        if (load1 > loadred) {
+                cpucolor = COL_RED;
+                addtobuffer(cpumsg, "&red Load is CRITICAL\n");
+        }
+        else if (load1 > loadyellow) {
+                cpucolor = COL_YELLOW;
+                addtobuffer(cpumsg, "&yellow Load is HIGH\n");
+        }
+        init_status(cpucolor);
+        sprintf(msgline, "status %s.cpu %s %s %s",
+                commafy(hostname), colorname(cpucolor),
+                (timestr ? timestr : "<No timestamp data>"),
+                cpuutilstr);
+
+        addtostatus(msgline);
+        /* And add the info if pb */
+        if (STRBUFLEN(cpumsg)) {
+                addtostrstatus(cpumsg);
+                addtostatus("\n");
+        }
+	/* And add the msg we recevied */
+        if (topstr) {
+                addtostatus(topstr);
+                addtostatus("\n");
+        }
+
+	dbgprintf("msgline %s", msgline); /* DEBUG TODO REMOVE */
+
+        if (fromline && !localmode) addtostatus(fromline);
+        finish_status();
+
+        freestrbuffer(cpumsg);
+}
+
+static void bbwin_clock_report(char *hostname, char *clientclass, enum ostype_t os,
+                     void *hinfo, char *fromline, char *timestr,
+                     char *clockstr, char *msgcachestr)
+{
+       	char *myclockstr;
+        int clockcolor = COL_GREEN;
+        float loadyellow, loadred;
+        int recentlimit, ancientlimit, maxclockdiff;
+        char msgline[4096];
+        strbuffer_t *clockmsg;
+
+        if (!want_msgtype(hinfo, MSG_CPU)) return;
+        if (!clockstr) return;
+
+	dbgprintf("Clock check host %s\n", hostname);
+
+	clockmsg = newstrbuffer(0);
+
+        myclockstr = strstr(clockstr, "local");
+        if (myclockstr) {
+                *(myclockstr - 1) = '\0';
+        }
+
+	get_cpu_thresholds(hinfo, clientclass, &loadyellow, &loadred, &recentlimit, &ancientlimit, &maxclockdiff);
+
+        if (clockstr) {
+                char *p;
+                struct timeval clockval;
+
+                p = strstr(clockstr, "epoch:");
+                if (p && (sscanf(p, "epoch: %ld.%ld", (long int *)&clockval.tv_sec, (long int *)&clockval.tv_usec) == 2)) {
+                        struct timeval clockdiff;
+                        struct timezone tz;
+                        int cachedelay = 0;
+
+                        if (msgcachestr) {
+                                /* Message passed through msgcache, so adjust for the cache delay */
+                                p = strstr(msgcachestr, "Cachedelay:");
+                                if (p) cachedelay = atoi(p+11);
+                        }
+
+                        gettimeofday(&clockdiff, &tz);
+                        clockdiff.tv_sec -= (clockval.tv_sec + cachedelay);
+                        clockdiff.tv_usec -= clockval.tv_usec;
+                        if (clockdiff.tv_usec < 0) {
+                                clockdiff.tv_usec += 1000000;
+                                clockdiff.tv_sec -= 1;
+                        }
+
+                        if ((maxclockdiff > 0) && (abs(clockdiff.tv_sec) > maxclockdiff)) {
+                                if (clockcolor == COL_GREEN) clockcolor = COL_YELLOW;
+                                sprintf(msgline, "&yellow System clock is %ld seconds off (max %ld)\n",
+                                        (long) clockdiff.tv_sec, (long) maxclockdiff);
+                                addtobuffer(clockmsg, msgline);
+                        }
+                        else {
+                                sprintf(msgline, "System clock is %ld seconds off\n", (long) clockdiff.tv_sec);
+                                addtobuffer(clockmsg, msgline);
+                        }
+                }
+        }
+
+        init_status(clockcolor);
+        sprintf(msgline, "status %s.timediff %s %s %s\n",
+                commafy(hostname), colorname(clockcolor),
+                (timestr ? timestr : "<No timestamp data>"),
+                ((clockcolor == COL_GREEN) ? "OK" : "NOT ok"));
+
+        addtostatus(msgline);
+        /* And add the info if pb */
+        if (STRBUFLEN(clockmsg)) {
+                addtostrstatus(clockmsg);
+                addtostatus("\n");
+        }
+        /* And add the msg we recevied */
+        if (myclockstr) {
+                addtostatus(myclockstr);
+                addtostatus("\n");
+        }
+
+        dbgprintf("msgline %s", msgline); /* DEBUG TODO REMOVE */
+
+        if (fromline && !localmode) addtostatus(fromline);
+        finish_status();
+
+        freestrbuffer(clockmsg);
+}
+
+void bbwin_who_report(char *hostname, char *clientclass, enum ostype_t os,
+                      void *hinfo, char *fromline, char *timestr, char *whostr)
+{
+        char *whockstr;
+        int whocolor = COL_GREEN;
+        char msgline[4096];
+        strbuffer_t *whomsg;
+
+        if (!want_msgtype(hinfo, MSG_WHO)) return;
+        if (!whostr) return;
+
+        dbgprintf("Who check host %s\n", hostname);
+
+        whomsg = newstrbuffer(0);
+
+        init_status(whocolor);
+        sprintf(msgline, "status %s.who %s %s %s\n",
+                commafy(hostname), colorname(whocolor),
+                (timestr ? timestr : "<No timestamp data>"),
+                ((whocolor == COL_GREEN) ? "OK" : "NOT ok"));
+
+        addtostatus(msgline);
+        /* And add the info if pb */
+        if (STRBUFLEN(whomsg)) {
+                addtostrstatus(whomsg);
+                addtostatus("\n");
+        }
+        /* And add the msg we recevied */
+        if (whostr) {
+                addtostatus(whostr);
+                addtostatus("\n");
+        }
+
+        dbgprintf("msgline %s", msgline); /* DEBUG TODO REMOVE */
+
+        if (fromline && !localmode) addtostatus(fromline);
+        finish_status();
+
+        freestrbuffer(whomsg);
+}
+
+void bbwin_svcs_report(char *hostname, char *clientclass, enum ostype_t os,
+                       void *hinfo, char *fromline, char *timestr,
+                       int namecol, int startupcol, int statecol, char *svcstr, char *svcauto)
+{
+        int svccolor = -1;
+        int schecks;
+        char msgline[4096];
+        static strbuffer_t *monmsg = NULL;
+        char *group;
+
+        if (!want_msgtype(hinfo, MSG_SVCS)) return;
+        if (!svcstr) return;
+
+        if (!monmsg) monmsg = newstrbuffer(0);
+
+	dbgprintf("Services check host %s\n", hostname);
+
+        clearalertgroups();
+        schecks = clear_svc_counts(hinfo, clientclass);
+	dbgprintf("schecks: [%d]\n", schecks); /* DEBUG TODO REMOVE */
+
+        if (schecks > 0) {
+                /* Count how many instances of each monitored condition are found */
+                char *sname, *bol, *nl;
+                int scount, scolor;
+                char *namestr, *startupstr, *statestr;
+
+                bol = svcstr;
+                while (bol) {
+                        char *p;
+
+                        nl = strchr(bol, '\n'); if (nl) *nl = '\0';
+
+                        /* Data lines */
+
+                        p = strdup(bol); namestr = getcolumn(p, namecol);
+                        strcpy(p, bol); startupstr = getcolumn(p, startupcol);
+                        strcpy(p, bol); statestr = getcolumn(p, statecol);
+
+                        add_svc_count(namestr, startupstr, statestr);
+
+                        xfree(p);
+
+                        if (nl) { *nl = '\n'; bol = nl+1; } else bol = NULL;
+                }
+
+                /* Check the status and state found for each monitored svc */
+                while ((sname = check_svc_count(&scount, &scolor, &group)) != NULL) {
+
+                        if (scolor > svccolor) svccolor = scolor;
+
+                        if (scolor == COL_GREEN) {
+                                sprintf(msgline, "&green %s\n", sname);
+                                addtobuffer(monmsg, msgline);
+                        }
+                        else {
+                                sprintf(msgline, "&%s %s\n",
+                                        colorname(scolor), sname);
+                                addtobuffer(monmsg, msgline);
+                                addalertgroup(group);
+                        }
+                }
+        }
+
+        if ((svccolor == -1) && sendclearsvcs) {
+                /* Nothing to check */
+                addtobuffer(monmsg, "No Services checks defined\n");
+		svccolor = noreportcolor;
+        }
+
+        if (svccolor != -1) {
+		if (svcauto && strlen(svcauto) > 1 && 
+			(svccolor == COL_GREEN || svccolor == noreportcolor)) 
+			svccolor = COL_YELLOW;
+
+                /* Now we know the result, so generate a status message */
+                init_status(svccolor);
+
+                group = getalertgroups();
+                if (group) sprintf(msgline, "status/group:%s ", group); else strcpy(msgline, "status ");
+                addtostatus(msgline);
+
+                sprintf(msgline, "%s.svcs %s %s - Services %s\n",
+                        commafy(hostname), colorname(svccolor),
+                        (timestr ? timestr : "<No timestamp data>"),
+                        ((svccolor == COL_GREEN) ? "OK" : "NOT ok"));
+                addtostatus(msgline);
+
+                /* And add the info about what's wrong */
+                addtostrstatus(monmsg);
+                addtostatus("\n");
+                clearstrbuffer(monmsg);
+
+		/* Add AutoRestart status */
+		if (svcauto && strlen(svcauto) > 1) {
+			addtostatus(svcauto); addtostatus("\n\n"); 
+		}
+
+                /* And the full svc output for those who want it */
+                if (svclistinsvcs) addtostatus(svcstr);
+
+                if (fromline) addtostatus(fromline);
+                finish_status();
+        }
+        else {
+                clearstrbuffer(monmsg);
+        }
+}
+
+void handle_win32_bbwin_client(char *hostname, char *clienttype, enum ostype_t os, 
+			 void *hinfo, char *sender, time_t timestamp,
+			 char *clientdata)
+{
+	char *timestr;
+	char *cpuutilstr;
+	char *uptimestr;
+	char *clockstr;
+	char *msgcachestr;
+	char *diskstr;
+	char *procsstr;	
+	char *msgsstr;
+	char *portsstr;
+	char *memorystr;
+	char *netstatstr;
+	char *ifstatstr;
+	char *svcstr;
+	char *svcauto;
+	char *whostr;
+
+	char fromline[1024];
+
+	sprintf(fromline, "\nStatus message received from %s\n", sender);
+
+	splitmsg(clientdata);
+
+	/* Get all data by section timestr is the date time for all status */ 
+	timestr = getdata("date");
+	if (!timestr) return;	
+
+	uptimestr = getdata("uptime");
+	clockstr = getdata("clock");
+	msgcachestr = getdata("msgcache"); /* TODO check when it is usefull */
+	cpuutilstr = getdata("cpu");
+	procsstr = getdata("procs");
+	diskstr = getdata("disk");
+	portsstr = getdata("ports");
+	memorystr = getdata("memory");
+	msgsstr = getdata("msg");
+        netstatstr = getdata("netstat");
+        ifstatstr = getdata("ifstat");
+	svcstr = getdata("svcs");
+	svcauto = getdata("svcautorestart");
+	whostr = getdata("who");
+
+	bbwin_uptime_report(hostname, clienttype, os, hinfo, fromline, timestr, uptimestr);
+	bbwin_clock_report(hostname, clienttype, os, hinfo, fromline, timestr, clockstr, msgcachestr);
+	bbwin_cpu_report(hostname, clienttype, os, hinfo, fromline, timestr, cpuutilstr);
+        unix_procs_report(hostname, clienttype, os, hinfo, fromline, timestr, "Name", NULL, procsstr);
+	unix_ports_report(hostname, clienttype, os, hinfo, fromline, timestr, 1, 2, 3, portsstr);
+	unix_disk_report(hostname, clienttype, os, hinfo, fromline, timestr, "Avail", "Capacity", "Filesystem", diskstr);
+	bbwin_svcs_report(hostname, clienttype, os, hinfo, fromline, timestr, 0, 1, 2, svcstr, svcauto);
+	bbwin_who_report(hostname, clienttype, os, hinfo, fromline, timestr, whostr);
+
+	msgs_report(hostname, clienttype, os, hinfo, fromline, timestr, msgsstr);
+        file_report(hostname, clienttype, os, hinfo, fromline, timestr);
+        linecount_report(hostname, clienttype, os, hinfo, fromline, timestr);
+
+	/* Data status */
+        unix_netstat_report(hostname, clienttype, os, hinfo, fromline, timestr, netstatstr);
+        unix_ifstat_report(hostname, clienttype, os, hinfo, fromline, timestr, ifstatstr);
+
+        if (memorystr) {
+                char *p;
+                long memphystotal, memphysused,
+                     memactused, memacttotal,
+                     memswaptotal, memswapused;
+
+                memphystotal = memswaptotal = memphysused = memswapused = memactused = memacttotal = -1;
+                p = strstr(memorystr, "\nphysical:");
+                if (p) sscanf(p, "\nphysical: %ld %ld", &memphystotal, &memphysused);
+		p = strstr(memorystr, "\npage:");
+                if (p) sscanf(p, "\npage: %ld %ld", &memswaptotal, &memswapused);
+                p = strstr(memorystr, "\nvirtual:");
+		if (p) sscanf(p, "\nvirtual: %ld %ld", &memacttotal, &memactused);
+		dbgprintf("DEBUG Memory %ld %ld %ld %ld %ld\n", memphystotal, memphysused, memactused, memswaptotal, memswapused); /* DEBUG TODO Remove*/
+                unix_memory_report(hostname, clienttype, os, hinfo, fromline, timestr,
+                                   memphystotal, memphysused, memactused, memswaptotal, memswapused);
+        }
+}
diff -Naur hobbitd/client_config.c hobbitd/client_config.c
--- hobbitd/client_config.c	2008-01-31 15:56:53.000000000 +0100
+++ hobbitd/client_config.c	2008-01-31 15:01:25.000000000 +0100
@@ -138,7 +138,16 @@
 	int color;
 } c_port_t;
 
-typedef enum { C_LOAD, C_UPTIME, C_CLOCK, C_DISK, C_MEM, C_PROC, C_LOG, C_FILE, C_DIR, C_PORT } ruletype_t;
+typedef struct c_svc_t {
+	exprlist_t *svcexp;
+	exprlist_t *stateexp;
+	exprlist_t *startupexp;
+	char *startup, *state;
+	int scount;
+	int color;
+} c_svc_t;
+
+typedef enum { C_LOAD, C_UPTIME, C_CLOCK, C_DISK, C_MEM, C_PROC, C_LOG, C_FILE, C_DIR, C_PORT, C_SVC } ruletype_t;
 
 typedef struct c_rule_t {
 	exprlist_t *hostexp;
@@ -163,6 +172,7 @@
 		c_file_t fcheck;
 		c_dir_t dcheck;
 		c_port_t port;
+		c_svc_t svc;
 	} rule;
 } c_rule_t;
 
@@ -733,6 +743,38 @@
 					}
 				} while (tok && (!isqual(tok)));
 			}
+                        else if (strcasecmp(tok, "SVC") == 0) {
+                               int idx = 0;
+
+                                currule = setup_rule(C_SVC, curhost, curexhost, curpage, curexpage, curclass, curexclass, 
+curtime, curtext, curgroup, cfid);
+
+				currule->rule.svc.svcexp = NULL;
+                                currule->rule.svc.startupexp = NULL;
+                                currule->rule.svc.stateexp = NULL;
+                                currule->rule.svc.state = NULL;
+                                currule->rule.svc.startup = NULL; 
+                                currule->rule.svc.color = COL_RED;
+
+                                tok = wstok(NULL);
+                                currule->rule.svc.svcexp = setup_expr(tok, 0);
+                                do {
+                                       tok = wstok(NULL); if (!tok || isqual(tok)) { idx = -1; continue; }
+
+                                        if (strncasecmp(tok, "startup=", 8) == 0) {
+                                                currule->rule.svc.startupexp = setup_expr(tok+8, 0);
+                                        }
+                                        else if (strncasecmp(tok, "status=", 7) == 0) {
+                                                currule->rule.svc.stateexp = setup_expr(tok+7, 0);
+                                        }
+                                        else if (strncasecmp(tok, "col=", 4) == 0) {
+                                                currule->rule.svc.color = parse_color(tok+4);
+                                        }
+                                        else if (strncasecmp(tok, "color=", 6) == 0) {
+                                                currule->rule.svc.color = parse_color(tok+6);
+                                        }
+                               } while (tok && (!isqual(tok)));
+                        }
 			else if (strcasecmp(tok, "FILE") == 0) {
 				currule = setup_rule(C_FILE, curhost, curexhost, curpage, curexpage, curclass, curexclass, curtime, curtext, curgroup, cfid);
 				currule->rule.fcheck.filename = NULL;
@@ -1150,6 +1192,18 @@
 				printf(" max=%d", rwalk->rule.port.pmax);
 			printf(" color=%s", colorname(rwalk->rule.port.color));
 			break;
+
+                  case C_SVC:
+                        printf("SVC");
+                        if (rwalk->rule.svc.svcexp)
+                                printf(" %s", rwalk->rule.svc.svcexp->pattern);
+                        if (rwalk->rule.svc.stateexp)
+                                printf(" status=%s", rwalk->rule.svc.stateexp->pattern);
+                        if (rwalk->rule.svc.startupexp)
+                                printf(" startup=%s", rwalk->rule.svc.startupexp->pattern);
+                        printf(" color=%s", colorname(rwalk->rule.svc.color));
+                        break;
+
 		}
 
 		if (rwalk->flags & CHK_TRACKIT) {
@@ -1821,6 +1875,7 @@
 		  case C_DISK : rule->rule.disk.dcount = 0; break;
 		  case C_PROC : rule->rule.proc.pcount = 0; break;
 		  case C_PORT : rule->rule.port.pcount = 0; break;
+		  case C_SVC : rule->rule.svc.scount = 0; break;
 		  default: break;
 		}
 
@@ -1916,6 +1971,20 @@
 			if (mymatch == 3) {pwalk->rule->rule.port.pcount++;}
 			break;
 
+                  case C_SVC: 
+                        mymatch = 0;
+
+                        if (check_expr_match(pname0, pwalk->rule->rule.svc.svcexp, NULL)) {
+                               mymatch++;
+                               pwalk->rule->rule.svc.startup = strdup(pname1);
+                               pwalk->rule->rule.svc.state = strdup(pname2);
+                              if (check_expr_match(pname1, pwalk->rule->rule.svc.startupexp, NULL)) mymatch++;
+            	              if (check_expr_match(pname2, pwalk->rule->rule.svc.stateexp, NULL)) mymatch++;
+                        }
+
+                        if (mymatch == 3) {pwalk->rule->rule.svc.scount++;}
+                        break;
+
 		  default:
 			break;
 		}
@@ -2004,6 +2073,56 @@
 		if (group) *group = (*walk)->rule->groups;
 		break;
 
+          case C_SVC:
+ 		result = (*walk)->rule->statustext;
+                if (!result) { 
+			int sz = 0;
+			char *p;
+
+			if ((*walk)->rule->rule.svc.svcexp->pattern)
+				sz = strlen((*walk)->rule->rule.svc.svcexp->pattern);
+			/* Current state */
+			if ((*walk)->rule->rule.svc.startup)
+				sz += strlen((*walk)->rule->rule.svc.startup);
+			else
+				sz += strlen("Not Found");
+			if ((*walk)->rule->rule.svc.state)
+				sz += strlen((*walk)->rule->rule.svc.state);
+			/* Rule state */
+			if ((*walk)->rule->rule.svc.startupexp->pattern)
+				sz += strlen((*walk)->rule->rule.svc.startupexp->pattern);
+                        if ((*walk)->rule->rule.svc.stateexp->pattern)
+                                sz += strlen((*walk)->rule->rule.svc.stateexp->pattern);
+
+			(*walk)->rule->statustext = (char *)malloc(sz + 12);
+			p = (*walk)->rule->statustext;
+			if ((*walk)->rule->rule.svc.svcexp->pattern)
+				p += sprintf(p, "%s is", (*walk)->rule->rule.svc.svcexp->pattern);
+			if ((*walk)->rule->rule.svc.startup)
+				p += sprintf(p, " %s", (*walk)->rule->rule.svc.startup);
+			else
+				p += sprintf(p, " %s", "Not Found");
+			if ((*walk)->rule->rule.svc.state)
+				p += sprintf(p, " %s",	(*walk)->rule->rule.svc.state);
+                        if ((*walk)->rule->rule.svc.startupexp->pattern)
+                                 p += sprintf(p, " req %s", (*walk)->rule->rule.svc.startupexp->pattern);
+			if ((*walk)->rule->rule.svc.stateexp->pattern)
+				p += sprintf(p, " %s", (*walk)->rule->rule.svc.stateexp->pattern);
+			*p = '\0';
+
+			result = (*walk)->rule->statustext;
+			/* We free the extra buffer */
+			if ((*walk)->rule->rule.svc.state)
+				xfree((*walk)->rule->rule.svc.state);
+			if ((*walk)->rule->rule.svc.startup)
+				xfree((*walk)->rule->rule.svc.startup);
+		}
+                *count = (*walk)->rule->rule.svc.scount;
+		*color = COL_GREEN;
+		if (*count == 0) *color = (*walk)->rule->rule.svc.color;
+                if (group) *group = (*walk)->rule->groups;
+                break;
+
 	  default: break;
 	}
 
@@ -2015,6 +2134,7 @@
 static mon_proc_t *phead = NULL, *ptail = NULL, *pmonwalk = NULL;
 static mon_proc_t *dhead = NULL, *dtail = NULL, *dmonwalk = NULL;
 static mon_proc_t *porthead = NULL, *porttail = NULL, *portmonwalk = NULL;
+static mon_proc_t *svchead = NULL, *svctail = NULL, *svcmonwalk = NULL;
 
 int clear_process_counts(namelist_t *hinfo, char *classname)
 {
@@ -2031,6 +2151,11 @@
 	return clear_counts(hinfo, classname, C_PORT, &porthead, &porttail, &portmonwalk);
 }
 
+int clear_svc_counts(void *hinfo, char *classname)
+{
+        return clear_counts(hinfo, classname, C_SVC, &svchead, &svctail, &svcmonwalk);
+}
+
 void add_process_count(char *pname)
 {
 	add_count(pname, phead);
@@ -2046,6 +2171,11 @@
 	add_count3(localstr, foreignstr, stname, porthead);
 }
 
+void add_svc_count(char *localstr, char *foreignstr, char *stname)
+{
+        add_count3(localstr, foreignstr, stname, svchead);
+}
+
 char *check_process_count(int *count, int *lowlim, int *uplim, int *color, char **id, int *trackit, char **group)
 {
 	return check_count(count, C_PROC, lowlim, uplim, color, &pmonwalk, id, trackit, group);
@@ -2061,3 +2191,7 @@
 	return check_count(count, C_PORT, lowlim, uplim, color, &portmonwalk, id, trackit, group);
 }
 
+char *check_svc_count(int *count, int *color, char **group)
+{
+        return check_count(count, C_SVC, NULL, NULL, color, &svcmonwalk, NULL, NULL, group);
+}
diff -Naur hobbitd/client_config.h hobbitd/client_config.h
--- hobbitd/client_config.h	2006-08-09 22:10:05.000000000 +0200
+++ hobbitd/client_config.h	2008-01-31 15:01:25.000000000 +0100
@@ -56,5 +56,9 @@
 extern void add_port_count(char *spname, char *tpname, char *stname);
 extern char *check_port_count(int *pcount, int *lowlim, int *uplim, int *pcolor, char **id, int *trackit, char **group);
 
+extern int clear_svc_counts(void *hinfo, char *classname); 
+extern void add_svc_count(char *spname, char *tpname, char *stname);
+extern char *check_svc_count(int *pcount, int *pcolor, char **group);
+
 #endif
 
diff -Naur hobbitd/hobbitd_client.c hobbitd/hobbitd_client.c
--- hobbitd/hobbitd_client.c	2008-01-31 15:56:53.000000000 +0100
+++ hobbitd/hobbitd_client.c	2008-01-31 15:01:25.000000000 +0100
@@ -29,7 +29,7 @@
 
 #define MAX_META 20	/* The maximum number of meta-data items in a message */
 
-enum msgtype_t { MSG_CPU, MSG_DISK, MSG_FILES, MSG_MEMORY, MSG_MSGS, MSG_PORTS, MSG_PROCS, MSG_LAST };
+enum msgtype_t { MSG_CPU, MSG_DISK, MSG_FILES, MSG_MEMORY, MSG_MSGS, MSG_PORTS, MSG_PROCS, MSG_SVCS, MSG_WHO, MSG_LAST };
 
 typedef struct sectlist_t {
 	char *sname;
@@ -39,9 +39,11 @@
 sectlist_t *sections = NULL;
 int pslistinprocs = 1;
 int portlistinports = 1;
+int svclistinsvcs = 1;
 int sendclearmsgs = 1;
 int sendclearfiles = 1;
 int sendclearports = 1;
+int sendclearsvcs = 1;
 int localmode     = 0;
 int noreportcolor = COL_CLEAR;
 
@@ -151,6 +153,8 @@
 				else if (strcmp(tok, "msgs") == 0) currset |= (1 << MSG_MSGS);
 				else if (strcmp(tok, "ports") == 0) currset |= (1 << MSG_PORTS);
 				else if (strcmp(tok, "procs") == 0) currset |= (1 << MSG_PROCS);
+				else if (strcmp(tok, "svcs") == 0) currset |= (1 << MSG_SVCS);
+				else if (strcmp(tok, "who") == 0) currset |= (1 << MSG_WHO);
 
 				tok = strtok(NULL, ",");
 			}
@@ -1402,6 +1406,7 @@
 #include "client/darwin.c"
 #include "client/irix.c"
 #include "client/sco_sv.c"
+#include "client/bbwin.c"
 
 static volatile int reloadconfig = 0;
 
@@ -1770,57 +1775,61 @@
 
 			combo_start();
 			switch (os) {
-			  case OS_FREEBSD: 
-				handle_freebsd_client(hostname, clientclass, os, hinfo, sender, timestamp, restofmsg);
-				break;
-
-			  case OS_NETBSD: 
-				handle_netbsd_client(hostname, clientclass, os, hinfo, sender, timestamp, restofmsg);
-				break;
-
-			  case OS_OPENBSD: 
-				handle_openbsd_client(hostname, clientclass, os, hinfo, sender, timestamp, restofmsg);
-				break;
-
-			  case OS_LINUX22: 
-			  case OS_LINUX: 
-			  case OS_RHEL3: 
-				handle_linux_client(hostname, clientclass, os, hinfo, sender, timestamp, restofmsg);
-				break;
-
-			  case OS_DARWIN:
-				handle_darwin_client(hostname, clientclass, os, hinfo, sender, timestamp, restofmsg);
-				break;
-
-			  case OS_SOLARIS: 
-				handle_solaris_client(hostname, clientclass, os, hinfo, sender, timestamp, restofmsg);
-				break;
+                          case OS_FREEBSD:
+                                handle_freebsd_client(hostname, clientclass, os, hinfo, sender, timestamp, restofmsg);
+                                break;
+
+                          case OS_NETBSD:
+                                handle_netbsd_client(hostname, clientclass, os, hinfo, sender, timestamp, restofmsg);
+                                break;
+
+                          case OS_OPENBSD:
+                                handle_openbsd_client(hostname, clientclass, os, hinfo, sender, timestamp, restofmsg);
+                                break;
+
+                          case OS_LINUX22:
+                          case OS_LINUX:
+                          case OS_RHEL3:
+                                handle_linux_client(hostname, clientclass, os, hinfo, sender, timestamp, restofmsg);
+                                break;
+
+                          case OS_DARWIN:
+                                handle_darwin_client(hostname, clientclass, os, hinfo, sender, timestamp, restofmsg);
+                                break;
+
+                          case OS_SOLARIS:
+                                handle_solaris_client(hostname, clientclass, os, hinfo, sender, timestamp, restofmsg);
+                                break;
+
+                          case OS_HPUX:
+                                handle_hpux_client(hostname, clientclass, os, hinfo, sender, timestamp, restofmsg);
+                                break;
+
+                          case OS_OSF:
+                                handle_osf_client(hostname, clientclass, os, hinfo, sender, timestamp, restofmsg);
+                                break;
+
+                          case OS_AIX:
+                                handle_aix_client(hostname, clientclass, os, hinfo, sender, timestamp, restofmsg);
+                                break;
+
+                          case OS_IRIX:
+                                handle_irix_client(hostname, clientclass, os, hinfo, sender, timestamp, restofmsg);
+                                break;
 
-			  case OS_HPUX: 
-				handle_hpux_client(hostname, clientclass, os, hinfo, sender, timestamp, restofmsg);
-				break;
-
-			  case OS_OSF: 
-				handle_osf_client(hostname, clientclass, os, hinfo, sender, timestamp, restofmsg);
-				break;
-
-			  case OS_AIX: 
-				handle_aix_client(hostname, clientclass, os, hinfo, sender, timestamp, restofmsg);
-				break;
-
-			  case OS_IRIX:
-				handle_irix_client(hostname, clientclass, os, hinfo, sender, timestamp, restofmsg);
-				break;
-				
                           case OS_SCO_SV:
-  			        handle_sco_sv_client(hostname, clientclass, os, hinfo, sender, timestamp, restofmsg);
-				break;
-				
-			  case OS_WIN32: 
-			  case OS_SNMP: 
-			  case OS_UNKNOWN:
-				errprintf("No client backend for OS '%s' sent by %s\n", clientos, sender);
-				break;
+                                handle_sco_sv_client(hostname, clientclass, os, hinfo, sender, timestamp, restofmsg);
+                                break;
+
+                          case OS_WIN32_BBWIN:
+                                handle_win32_bbwin_client(hostname, clientclass, os, hinfo, sender, timestamp, restofmsg);
+                                break;
+
+                          case OS_WIN32:
+                          case OS_SNMP:
+                          case OS_UNKNOWN:
+                                errprintf("No client backend for OS '%s' sent by %s\n", clientos, sender);
+                                break;
 			}
 			combo_end();
 		}
diff -Naur hobbitd/rrd/do_disk.c hobbitd/rrd/do_disk.c
--- hobbitd/rrd/do_disk.c	2006-08-09 22:10:06.000000000 +0200
+++ hobbitd/rrd/do_disk.c	2007-12-27 13:58:20.000000000 +0100
@@ -2,6 +2,7 @@
 /* Hobbit RRD handler module.                                                 */
 /*                                                                            */
 /* Copyright (C) 2004-2006 Henrik Storner <henrik@hswn.dk>                    */
+/* Copyright (C) 2007 Francois Lacroix					      */
 /*                                                                            */
 /* This program is released under the GNU General Public License (GPL),       */
 /* version 2. See the file "COPYING" for details.                             */
@@ -16,7 +17,7 @@
 					rra1, rra2, rra3, rra4, NULL };
 	static char *disk_tpl      = NULL;
 
-	enum { DT_IRIX, DT_AS400, DT_NT, DT_UNIX, DT_NETAPP, DT_NETWARE } dsystype;
+	enum { DT_IRIX, DT_AS400, DT_NT, DT_UNIX, DT_NETAPP, DT_NETWARE, DT_BBWIN } dsystype;
 	char *eoln, *curline;
 	static int ptnsetup = 0;
 	static pcre *inclpattern = NULL;
@@ -48,6 +49,7 @@
 	else if (strstr(msg, "DASD")) dsystype = DT_AS400;
 	else if (strstr(msg, "NetWare Volumes")) dsystype = DT_NETWARE;
 	else if (strstr(msg, "NetAPP")) dsystype = DT_NETAPP;
+	else if (strstr(msg, "Summary")) dsystype = DT_BBWIN; /* Make sur it is a bbwin client v > 0.10 */
 	else if (strstr(msg, "Filesystem")) dsystype = DT_NT;
 	else dsystype = DT_UNIX;
 
@@ -83,6 +85,8 @@
 		 * Some Unix filesystem reports contain the word "Filesystem".
 		 * So check if there's a slash in the NT filesystem letter - if yes,
 		 * then it's really a Unix system after all.
+		 * Not always has BBWIN > 0.10 not give the information also on mounted disk.
+		 * (IE more than one letter)
 		 */
 		if ( (dsystype == DT_NT) && (*(columns[5])) &&
 		     ((strchr(columns[0], '/')) || (strlen(columns[0]) > 1)) )
@@ -112,6 +116,7 @@
 			pused = atoi(columns[columncount-1]);
 			aused = 0; /* Not available */
 			break;
+		  case DT_BBWIN:
 		  case DT_NT:
 			diskname = xmalloc(strlen(columns[0])+2);
 			sprintf(diskname, "/%s", columns[0]);
diff -Naur hobbitd/rrd/do_ifstat.c hobbitd/rrd/do_ifstat.c
--- hobbitd/rrd/do_ifstat.c	2006-08-09 22:10:06.000000000 +0200
+++ hobbitd/rrd/do_ifstat.c	2008-01-31 15:01:25.000000000 +0100
@@ -2,6 +2,7 @@
 /* Hobbit RRD handler module.                                                 */
 /*                                                                            */
 /* Copyright (C) 2005-2006 Henrik Storner <henrik@hswn.dk>                    */
+/* Copyright (C) 2007 Francois Lacroix					      */
 /*                                                                            */
 /* This program is released under the GNU General Public License (GPL),       */
 /* version 2. See the file "COPYING" for details.                             */
@@ -102,6 +103,12 @@
 	"^([a-z]+[0-9]+)\\s+[0-9]+\\s+[0-9.]+\\s+[0-9.]+\\s+([0-9]+)\\s+[0-9]+\\s+([0-9]+)\\s+"
 };
 
+/* IP          Ibytes Obytes */
+/* 192.168.0.1 1818   1802  */
+static const char *ifstat_bbwin_exprs[] = {
+        "^([a-zA-Z0-9.:]+)\\s+([0-9]+)\\s+([0-9]+)"
+};
+
 int do_ifstat_rrd(char *hostname, char *testname, char *msg, time_t tstamp)
 {
 	static int pcres_compiled = 0;
@@ -114,6 +121,7 @@
 	static pcre **ifstat_aix_pcres = NULL;
 	static pcre **ifstat_hpux_pcres = NULL;
 	static pcre **ifstat_sco_sv_pcres = NULL;
+	static pcre **ifstat_bbwin_pcres = NULL;
 
 	enum ostype_t ostype;
 	char *datapart = msg;
@@ -141,6 +149,8 @@
 						 (sizeof(ifstat_hpux_exprs) / sizeof(ifstat_hpux_exprs[0])));
 		ifstat_sco_sv_pcres = compile_exprs("SCO_SV", ifstat_sco_sv_exprs, 
 						 (sizeof(ifstat_sco_sv_exprs) / sizeof(ifstat_sco_sv_exprs[0])));
+                ifstat_bbwin_pcres = compile_exprs("BBWIN", ifstat_bbwin_exprs, 
+                                                 (sizeof(ifstat_bbwin_exprs) / sizeof(ifstat_bbwin_exprs[0])));
 	}
 
 
@@ -247,6 +257,10 @@
 		        if (pickdata(bol, ifstat_sco_sv_pcres[0], 0, &ifname, &rxstr, &txstr)) dmatch = 7;
 			break;
 			
+		  case OS_WIN32_BBWIN:
+                        if (pickdata(bol, ifstat_bbwin_pcres[0], 0, &ifname, &rxstr, &txstr)) dmatch = 7;
+                        break;
+			
 		  case OS_OSF:
 		  case OS_IRIX:
 		  case OS_SNMP:
diff -Naur hobbitd/rrd/do_netstat.c hobbitd/rrd/do_netstat.c
--- hobbitd/rrd/do_netstat.c	2006-08-09 22:10:06.000000000 +0200
+++ hobbitd/rrd/do_netstat.c	2007-12-27 13:58:20.000000000 +0100
@@ -2,6 +2,7 @@
 /* Hobbit RRD handler module.                                                 */
 /*                                                                            */
 /* Copyright (C) 2004-2006 Henrik Storner <henrik@hswn.dk>                    */
+/* Copyright (C) 2007 Francois Lacroix					      */
 /*                                                                            */
 /* This program is released under the GNU General Public License (GPL),       */
 /* version 2. See the file "COPYING" for details.                             */
@@ -512,6 +513,7 @@
 		break;
 
 	  case OS_WIN32:
+	  case OS_WIN32_BBWIN:
 		havedata = do_valaftermarkerequal(netstat_win32_markers, datapart, outp);
 		break;
 
diff -Naur hobbitd/rrd/do_vmstat.c hobbitd/rrd/do_vmstat.c
--- hobbitd/rrd/do_vmstat.c	2006-08-09 22:10:06.000000000 +0200
+++ hobbitd/rrd/do_vmstat.c	2007-12-27 13:58:20.000000000 +0100
@@ -2,6 +2,7 @@
 /* Hobbit RRD handler module.                                                 */
 /*                                                                            */
 /* Copyright (C) 2004-2006 Henrik Storner <henrik@hswn.dk>                    */
+/* Copyright (C) 2007 Francois Lacroix					      */
 /*                                                                            */
 /* This program is released under the GNU General Public License (GPL),       */
 /* version 2. See the file "COPYING" for details.                             */
@@ -338,6 +339,7 @@
 	  case OS_HPUX: 
 		layout = vmstat_hpux_layout; break;
 	  case OS_WIN32:
+	  case OS_WIN32_BBWIN:
 		errprintf("Cannot handle Win32 vmstat from host '%s' \n", hostname);
 		return -1;
 	  case OS_FREEBSD:
diff -Naur lib/misc.c lib/misc.c
--- misc.c	2007-10-30 14:21:02.000000000 +0100
+++ lib/misc.c	2007-12-18 10:09:00.000000000 +0100
@@ -69,6 +69,7 @@
 	else if (strcasecmp(osname, "macosx") == 0)      result = OS_DARWIN;
 	else if (strcasecmp(osname, "darwin") == 0)      result = OS_DARWIN;
 	else if (strcasecmp(osname, "sco_sv") == 0)      result = OS_SCO_SV;
+	else if (strcasecmp(osname, "bbwin") == 0)      result = OS_WIN32_BBWIN;
 
 	if (result == OS_UNKNOWN) dbgprintf("Unknown OS: '%s'\n", osname);
 
@@ -94,6 +95,7 @@
 		case OS_IRIX: return "irix";
 		case OS_DARWIN: return "darwin";
 	        case OS_SCO_SV: return "sco_sv";
+		case OS_WIN32_BBWIN: return "bbwin";
 		case OS_UNKNOWN: return "unknown";
 	}
 
diff -Naur lib/misc.h lib/misc.h
--- lib/misc.h	2006-08-09 22:10:16.000000000 +0200
+++ lib/misc.h	2007-12-12 11:42:53.000000000 +0100
@@ -13,7 +13,7 @@
 
 #include <stdio.h>
 
-enum ostype_t { OS_UNKNOWN, OS_SOLARIS, OS_OSF, OS_AIX, OS_HPUX, OS_WIN32, OS_FREEBSD, OS_NETBSD, OS_OPENBSD, OS_LINUX22, OS_LINUX, OS_RHEL3, OS_SNMP, OS_IRIX, OS_DARWIN, OS_SCO_SV } ;
+enum ostype_t { OS_UNKNOWN, OS_SOLARIS, OS_OSF, OS_AIX, OS_HPUX, OS_WIN32, OS_FREEBSD, OS_NETBSD, OS_OPENBSD, OS_LINUX22, OS_LINUX, OS_RHEL3, OS_SNMP, OS_IRIX, OS_DARWIN, OS_SCO_SV , OS_WIN32_BBWIN } ;
 
 extern enum ostype_t get_ostype(char *osname);
 extern char *osname(enum ostype_t os);
